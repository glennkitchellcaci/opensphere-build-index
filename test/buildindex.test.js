const Promise = require('bluebird');
const fs = Promise.promisifyAll(require('fs'));
const rimraf = Promise.promisify(require('rimraf'));
const mkdirp = Promise.promisifyAll(require('mkdirp'));

const osIndex = require('../buildindex.js');
const expect = require('chai').expect;
const path = require('path');

const mockDir = path.resolve(__dirname, 'mock');
const modulesDir = path.join(mockDir, 'node_modules', 'test');
const buildDir = path.join(mockDir, '.build');
const distDir = path.join(mockDir, 'dist');
const numResources = 5;

/**
 * The gcc manifest file generated by opensphere-build-resolver.
 * @type {string}
 */
const manifestFile = 'gcc-manifest';

const baseTemplate = '<!DOCTYPE html>\n\
<title>Test Template</title>\n\
<!--VENDOR_CSS-->\n\
<!--APP_CSS-->\n\
<div id="ng-app" ng-init="version=\'@appVersion@\';versionPath=\'@version@\'">\n\
  <test-app></test-app>\n\
</div>\n\
<!--VENDOR_JS-->\n\
<!--APP_JS-->';

/**
 * The resource files generated by the opensphere-build-resolver resource plugin.
 * @type {!Array<string>}
 */
const resourceFiles = [
  'resources-css-debug-index1',
  'resources-css-debug-index2',
  'resources-css-dist-index1',
  'resources-css-dist-index2',
  'resources-js-debug-index1',
  'resources-js-debug-index2',
  'resources-js-dist-index1',
  'resources-js-dist-index2',
];

/**
 * Recreate the build directory.
 * @return {Promise} A promise that resolves when the directory is ready.
 */
const cleanMockDirectory = function() {
  return rimraf(mockDir)
      .then(function() {
        return Promise.map([buildDir, distDir, modulesDir], function(dir) {
          return mkdirp.mkdirpAsync(dir);
        });
      });
};

/**
 * Generate HTML templates.
 * @return {Promise} A promise that resolves when the templates are ready.
 */
const generateTemplates = function() {
  return Promise.map([path.join(mockDir, 'index1-template.html'),
    path.join(modulesDir, 'index2-template.html')], function(file) {
    return fs.writeFileAsync(file, baseTemplate);
  });
};

/**
 * Generate a test file.
 * @return {Promise} A promise that resolves when the files have been created.
 */
const generateResourceFiles = function() {
  return Promise.map(resourceFiles, function(fileName) {
    const filePath = path.join(buildDir, fileName);

    const fileParts = fileName.split('-');
    const ext = '.' + fileParts[1];

    const resourcePath = fileParts.join(path.sep);
    const resources = [];
    for (var i = 0; i < numResources; i++) {
      resources.push(path.join(resourcePath, i + ext));
    }

    const content = resources.join('\n');
    return fs.writeFileAsync(filePath, content);
  });
};

/**
 * Generate the gcc manifest file.
 * @return {Promise} A promise that resolves when the manifest has been created.
 */
const generateManifest = function() {
  const filePath = path.join(buildDir, manifestFile);
  const manifestFiles = resourceFiles.map(function(file) {
    return path.join(buildDir, file);
  });

  return fs.writeFileAsync(filePath, manifestFiles.join('\n'));
};

/**
 * Generate the index files.
 * @return {Promise} A promise that resolves when generation completes.
 */
const generateIndex = function() {
  return osIndex.buildIndex({
    appVersion: 'test-version',
    basePath: mockDir,
    distPath: path.join('test', 'mock', 'dist'),
    templates: [
      {
        id: 'index1',
      },
      {
        id: 'index2',
        file: path.join(modulesDir, 'index2-template.html'),
      },
    ],
    debugCss: path.join('styles', 'debug.css'),
    compiledCss: path.join('styles', 'test.min.css'),
    compiledJs: 'test.min.js',
  });
};

before(function() {
  return cleanMockDirectory()
      .then(generateTemplates)
      .then(generateResourceFiles)
      .then(generateManifest)
      .then(generateIndex);
});

describe('opensphere-build-index', function() {
  describe('debug index', function() {
    var indexFiles = {};
    var indexScripts = {};

    it('generates debug index files from the templates', function() {
      expect(fs.existsSync(path.join(mockDir, 'index1.html')))
          .to.equal(true, 'first debug template missing');
      expect(fs.existsSync(path.join(mockDir, 'index2.html')))
          .to.equal(true, 'second debug template missing');
    });

    it('reads the debug index', function() {
      return Promise.map(['index1.html', 'index2.html'], function(fileName) {
        var key = fileName.replace(/\..*/, '');
        var scripts = require(path.join(buildDir, key + '-debug-scripts.json'));
        expect(Array.isArray(scripts)).to.equal(true);

        indexScripts[key] = scripts;

        return fs.readFileAsync(path.join(mockDir, fileName), 'utf8').then(function(file) {
          indexFiles[key] = file;

          return Promise.resolve();
        });
      })
          .catch(function(e) {
            expect(e).to.equal(null, 'encountered an error reading index', e);
          });
    });

    it('replaces the version strings', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];
        var lines = index.split('\n');
        var versionLine = lines.find(function(line) {
          return /ng-init="version='dev';versionPath=''"/.test(line);
        });

        expect(versionLine).not.to.equal(null);
      }
    });

    it('adds link tags to the index', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];

        var lines = index.split('\n');
        var links = lines.filter(function(line) {
          return /^<link /.test(line);
        });

        expect(links.length).to.equal(numResources + 1, key + ' has incorrect number of link elements');

        for (var i = 0; i < numResources; i++) {
          var linkUrl = 'resources/css/debug/' + key + '/' + i + '.css';
          var linkTag = '<link rel="stylesheet" href="' + linkUrl + '">';
          expect(links[i]).to.equal(linkTag, key + ' missing css file from gcc resources');
        }

        expect(links[numResources]).to.equal('<link rel="stylesheet" href="styles/debug.css">');
      }
    });

    it('adds script tags to the index', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];
        var scripts = indexScripts[key];

        var lines = index.split('\n');
        var scriptTags = lines.filter(function(line) {
          return /^<script[> ]/.test(line);
        });
        expect(scriptTags.length).to.equal(2, key + ' has incorrect number of script elements');
        expect(scriptTags[0]).to.equal('<script>window.DEBUG_SCRIPTS_PATH=".build/' + key +
            '-debug-scripts.json";</script>', key + ' has invalid debug scripts path');
        expect(scriptTags[1]).to.equal('<script src=".build/debug-loader.js"></script>',
            key + ' has a missing/unexpected debug loader');

        var expectedScripts = numResources + 1 + resourceFiles.length;
        expect(scripts.length).to.equal(expectedScripts, key + ' has incorrect number of debug scripts');

        for (var i = 0; i < numResources; i++) {
          var scriptUrl = 'resources/js/debug/' + key + '/' + i + '.js';
          expect(scripts[i]).to.equal(scriptUrl, key + ' missing/incorrect js file from gcc resources');
        }

        expect(scripts[numResources]).to.equal('.build/gcc-defines-debug.js', key + ' missing gcc debug defines');

        resourceFiles.forEach(function(resource, idx, arr) {
          var scriptPath = '.build/' + resource;
          expect(scripts[numResources + 1 + idx]).to.equal(scriptPath,
              key + ' missing/incorrect script from gcc manifest');
        });
      }
    });
  });

  describe('distribution index', function() {
    var indexFiles = {};

    it('generates distribution index files from the templates', function() {
      expect(fs.existsSync(path.join(distDir, 'index1.html')))
          .to.equal(true, 'first dist template missing');
      expect(fs.existsSync(path.join(distDir, 'index2.html')))
          .to.equal(true, 'first second template missing');
    });

    it('reads the distribution index', function() {
      return Promise.map(['index1.html', 'index2.html'], function(fileName) {
        return fs.readFileAsync(path.join(distDir, fileName), 'utf8').then(function(file) {
          var key = fileName.replace(/\.html/, '');
          indexFiles[key] = file;

          return Promise.resolve();
        });
      })
          .catch(function(e) {
            expect(e).to.equal(null, 'encountered an error reading index', e);
          });
    });

    it('replaces the version strings', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];
        var lines = index.split('\n');
        var versionLine = lines.find(function(line) {
          return /ng-init="version='test-version';versionPath='test-version\/'"/.test(line);
        });

        expect(versionLine).not.to.equal(null);
      }
    });

    it('adds link tags to the index', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];

        var lines = index.split('\n');
        var links = lines.filter(function(line) {
          return /^<link /.test(line);
        });

        expect(links.length).to.equal(numResources + 1, key + ' has incorrect number of link elements');

        for (var i = 0; i < numResources; i++) {
          var linkUrl = 'resources/css/dist/' + key + '/' + i + '.css';
          var linkTag = '<link rel="stylesheet" href="' + linkUrl + '">';
          expect(links[i]).to.equal(linkTag, key + ' missing css file from gcc resources');
        }

        expect(links[numResources]).to.equal('<link rel="stylesheet" href="styles/test.min.css">',
            key + ' missing compiled css file');
      }
    });

    it('adds script tags to the index', function() {
      for (var key in indexFiles) {
        var index = indexFiles[key];

        var lines = index.split('\n');
        var scripts = lines.filter(function(line) {
          return /^<script src=/.test(line);
        });

        expect(scripts.length).to.equal(numResources + 1, key + ' has incorrect number of script elements');

        for (var i = 0; i < numResources; i++) {
          var scriptUrl = 'resources/js/dist/' + key + '/' + i + '.js';
          var scriptTag = '<script src="' + scriptUrl + '"></script>';
          expect(scripts[i]).to.equal(scriptTag, key + ' missing/incorrect js file from gcc resources');
        }

        expect(scripts[numResources]).to.equal('<script src="test.min.js"></script>',
            key + ' missing compiled js file');
      }
    });
  });
});
